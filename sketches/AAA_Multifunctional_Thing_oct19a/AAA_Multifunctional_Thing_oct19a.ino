#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/a8270e8e-b5e8-402a-b625-c4e1b917dc88

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String logMessage;
  float humidity;
  int countdownMinutes;
  int distance;
  int distance_threshold;
  bool buzzer;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include "thingProperties.h"
#include "Arduino_LED_Matrix.h"
#include "digits.h"

#define LOG_DELAY 1 * 60 * 1000
#define HUMIDITY_SENSOR_DELAY 5 * 1000
#define HUMIDITY_SENSOR_POWER 3
#define HUMIDITY_SENSOR_ANALOG_PIN A0

#define DISTANCE_MEASURE_DELAY 1 * 1000
#define DISTANCE_TRIG_PIN 13
#define DISTANCE_ECHO_PIN 12
#define LOG_DISTANCE 1

#define DISTANCE_VERY_CLOSE 1
#define DISTANCE_CLOSE 2
#define DISTANCE_FAR 3
#define DISTANCE_VERY_CLOSE_THRESHOLD 15
#define DISTANCE_CLOSE_THRESHOLD 30

#define BUZZER_PIN 9

#define MATRIX_DELAY_MINUTE 60 * 1000
#define MATRIX_DELAY_SECOND 5 * 1000

unsigned long countdownMinutesTime;
unsigned long countdownSecondsTime;
unsigned long countdownSeconds = 0;

ArduinoLEDMatrix matrix;
unsigned long readHumidityTime;
unsigned long logDeviceTime;
unsigned long readDistanceTime;
bool isConnectedToCloud = false;

unsigned long matrixCounterTime;
unsigned long matrixCounter = 0;

uint32_t frame[] = {
  0, 0, 0, 0
};

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  pinMode(HUMIDITY_SENSOR_POWER, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(DISTANCE_TRIG_PIN, OUTPUT);
  pinMode(DISTANCE_ECHO_PIN, INPUT);
  pinMode(LED_BUILTIN, OUTPUT);

  tone(BUZZER_PIN, 3 * 440, 100);
  delay(100);
  tone(BUZZER_PIN, 4 * 440, 100);
  digitalWrite(LED_BUILTIN, HIGH);

  matrix.begin();

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  logDeviceTime = readHumidityTime = countdownMinutesTime = millis();
}


void loop() {
  ArduinoCloud.update();

  if (!isConnectedToCloud) {
    if (ArduinoCloud.connected()) {
      digitalWrite(LED_BUILTIN, LOW);
      tone(BUZZER_PIN, 4 * 440, 100);
      delay(100);
      tone(BUZZER_PIN, 3 * 440, 100);
      isConnectedToCloud = true;
      matrix.loadFrame(frame);
      matrixCounterTime = millis();
    }
  }

  long currentTime = millis();

  if (countdownMinutes > 0) {
    if (currentTime - countdownMinutesTime > MATRIX_DELAY_MINUTE) {
      Serial.print("COUNTDOWN: ");
      Serial.println(countdownMinutes);
      if (countdownMinutes >= 0) {
        countdownMinutes -= 1;
        writeNumbers(frame, countdownMinutes / 10, countdownMinutes % 10);
      } else {
        writeNumbers(frame, 0, 0);
      }
      countdownMinutesTime = currentTime;
    }

    if (currentTime - countdownSecondsTime > MATRIX_DELAY_SECOND) {
      if (countdownMinutes > 0) {
        countdownSeconds = (countdownSeconds + 5) % 60;
        countdownSecondsTime = currentTime;

        frame[0] = 0x000FFFFF & frame[0];  //   & 0x05F | frame[0];
        frame[0] = 1 << (31 - countdownSeconds / 5) | frame[0];
        matrix.loadFrame(frame);
      }
    }
  } else {
    frame[0] = 0;
    frame[1] = 0;
    frame[2] = 0;
    frame[3] = 0;
    matrix.loadFrame(frame);
  }

  if (currentTime - logDeviceTime > LOG_DELAY) {
    logMessage = String("After " + String(currentTime / 1000) + " I'm still alive");
    logDeviceTime = currentTime;
  }

  if (currentTime - readDistanceTime > DISTANCE_MEASURE_DELAY) {
    digitalWrite(DISTANCE_TRIG_PIN, LOW);
    delayMicroseconds(2);
    digitalWrite(DISTANCE_TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(DISTANCE_TRIG_PIN, LOW);


    const unsigned long duration = pulseIn(DISTANCE_ECHO_PIN, HIGH);
    if (duration == 0) {
      Serial.println("Warning: no pulse from sensor");
      distance = 0;
    } else {
      // The speed of sound is 340 m/s or 29 microseconds per centimetre.
      // The ping travels out and back, so to find the distance of the
      // object we take half of the distance travelled.
      distance = duration / 29 / 2;
      if (distance <= DISTANCE_VERY_CLOSE_THRESHOLD) {
        distance_threshold = DISTANCE_VERY_CLOSE;
      } else if (distance <= DISTANCE_CLOSE_THRESHOLD) {
        distance_threshold = DISTANCE_CLOSE;
      } else {
        distance_threshold = DISTANCE_FAR;
      }
      if (LOG_DISTANCE) {
        Serial.print("distance to nearest object: ");
        Serial.print(distance);
        Serial.println(" cm");
        Serial.print("Threshold is ");
        Serial.println(distance_threshold);
      }
    }
    readDistanceTime = currentTime;
  }

  if (currentTime - readHumidityTime > HUMIDITY_SENSOR_DELAY) {
    digitalWrite(HUMIDITY_SENSOR_POWER, HIGH);  // Turn the sensor ON
    delay(100);                                 // Allow power to settle
    int readValue = analogRead(HUMIDITY_SENSOR_ANALOG_PIN);
    humidity = convertToPercent(readValue);
    delay(100);                                // just to see the led blinking
    digitalWrite(HUMIDITY_SENSOR_POWER, LOW);  // Turn the sensor OFF
    Serial.print("Humidity (");
    Serial.print(readValue);
    Serial.print("): ");
    Serial.print(humidity);
    Serial.println("%");
    readHumidityTime = currentTime;
  }
}

int convertToPercent(int value) {
  long perc = map(value, 1023, 215, 0, 100);
  if (perc > 100) {
    perc = 100;
  }
  return perc;
}

/*
  Since Buzzer is READ_WRITE variable, onBuzzerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBuzzerChange() {
  // Add your code here to act upon Buzzer change
  if (buzzer) {
    tone(BUZZER_PIN, 2 * 440);
  } else {
    noTone(BUZZER_PIN);
  }
}

void writeNumbers(unsigned long *ar, int first, int second) {
  ar[0] =
    digits[first][0] << 26 | digits[second][0] << 20 | digits[first][1] << 14 | digits[second][1] << 8 | digits[first][2] << 2 | digits[second][2] >> 4;

  ar[1] =
    digits[second][2] << 28 | digits[first][3] << 22 | digits[second][3] << 16 | digits[first][4] << 10 | digits[second][4] << 4 | digits[first][5] >> 2;

  ar[2] =
    digits[first][5] << 30 | digits[second][5] << 24 | digits[first][6] << 18 | digits[second][6] << 12 | digits[first][7] << 6 | digits[second][7];
}



/*
  Since CountdownMinutes is READ_WRITE variable, onCountdownMinutesChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCountdownMinutesChange() {
  // Add your code here to act upon CountdownMinutes change
  Serial.print("**** received countdown: ");
  Serial.println(countdownMinutes);
  countdownSeconds = 0;
  if (countdownMinutes >= 0) {
    writeNumbers(frame, countdownMinutes / 10, countdownMinutes % 10);
  } else {
    writeNumbers(frame, 0, 0);
  }
  matrix.loadFrame(frame);
  countdownSecondsTime = countdownMinutesTime = millis();
}